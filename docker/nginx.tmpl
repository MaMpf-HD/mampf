{{ $CurrentContainer := where $ "ID" .Docker.CurrentContainerID | first }}
{{ $debug_all := $.Env.DEBUG }}

{{ define "echo_subrequests" }}
	{{ $networks := .Networks }}
    location {{ .Endpoint }} {
        types { } default_type "text/html; charset=utf-8";
    {{ $server_found := "false" }}
    {{ range $container := .Containers }}
        {{/* If only 1 port exposed, use that as a default, else 80 */}}
        {{ $defaultPort := (when (eq (len $container.Addresses) 1) (first $container.Addresses) (dict "Port" "80")).Port }}
        {{ $port := (coalesce $container.Env.VIRTUAL_PORT $defaultPort) }}
        {{ $address := where $container.Addresses "Port" $port | first }}
        {{ range $knownNetwork := $networks }}
            {{ range $containerNetwork := $container.Networks }}
                {{ if (and (ne $containerNetwork.Name "ingress") (or (eq $knownNetwork.Name $containerNetwork.Name) (eq $knownNetwork.Name "host"))) }}
                    {{ if $address }}
                        {{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}
                        {{ if and $container.Node.ID $address.HostPort }}
                            {{ $server_found = "true" }}
        # {{ $container.Node.Name }}/{{ $container.Name }}
        echo_subrequest_async GET 'http://{{ $container.Node.Address.IP }}:{{ $address.HostPort }}/metrics';
                        {{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
                        {{ else if $containerNetwork }}
                            {{ $server_found = "true" }}
        # {{ $container.Name }}
        echo_subrequest_async GET 'http://{{ $containerNetwork.IP }}:{{ $address.Port }}/metrics';
                        {{ end }}
                    {{ else if $containerNetwork }}
        # {{ $container.Name }}
                        {{ if $containerNetwork.IP }}
                            {{ $server_found = "true" }}
        echo_subrequest_async GET 'http://{{ $containerNetwork.IP }}:{{ $port }}/metrics';
                        {{ end }}
                    {{ end }}
                {{ end }}
            {{ end }}
        {{ end }}
    {{ end }}
    {{ if (eq $server_found "false") }}
        # Fallback entry
        return 200 '';
    {{ end }}
    }
{{ end }}

{{ define "upstream" }}
    {{ $fail_timeout := "5s" }}
    {{ $max_fails := "3" }}
	{{ $networks := .Networks }}
	{{ $debug_all := .Debug }}
	upstream {{ .Upstream }} {
	{{ $server_found := "false" }}
	{{ range $container := .Containers }}
        {{ $debug := (eq (coalesce $container.Env.DEBUG $debug_all "false") "true") }}
        {{/* If only 1 port exposed, use that as a default, else 80 */}}
        {{ $defaultPort := (when (eq (len $container.Addresses) 1) (first $container.Addresses) (dict "Port" "80")).Port }}
        {{ $port := (coalesce $container.Env.VIRTUAL_PORT $defaultPort) }}
        {{ $address := where $container.Addresses "Port" $port | first }}
        {{ if $debug }}
        # Exposed ports: {{ $container.Addresses }}
        # Default virtual port: {{ $defaultPort }}
        # VIRTUAL_PORT: {{ $container.Env.VIRTUAL_PORT }}
            {{ if not $address }}
        # /!\ Virtual port not exposed
            {{ end }}
        {{ end }}
		{{ range $knownNetwork := $networks }}
			{{ range $containerNetwork := $container.Networks }}
				{{ if (and (ne $containerNetwork.Name "ingress") (or (eq $knownNetwork.Name $containerNetwork.Name) (eq $knownNetwork.Name "host"))) }}
        ## Can be connected with "{{ $containerNetwork.Name }}" network
                    {{ if $address }}
                        {{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}
                        {{ if and $container.Node.ID $address.HostPort }}
                            {{ $server_found = "true" }}
        # {{ $container.Node.Name }}/{{ $container.Name }}
        server {{ $container.Node.Address.IP }}:{{ $address.HostPort }} max_fails={{ $max_fails }} fail_timeout={{ $fail_timeout }};
                        {{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
                        {{ else if $containerNetwork }}
                            {{ $server_found = "true" }}
        # {{ $container.Name }}
        server {{ $containerNetwork.IP }}:{{ $address.Port }} max_fails={{ $max_fails }} fail_timeout={{ $fail_timeout }};
                        {{ end }}
                    {{ else if $containerNetwork }}
        # {{ $container.Name }}
                        {{ if $containerNetwork.IP }}
                            {{ $server_found = "true" }}
        server {{ $containerNetwork.IP }}:{{ $port }} max_fails={{ $max_fails }} fail_timeout={{ $fail_timeout }};
                        {{ else }}
        # /!\ No IP for this network!
                    	{{ end }}
					{{ end }}
				{{ else }}
        # Cannot connect to network '{{ $containerNetwork.Name }}' of this container
				{{ end }}
			{{ end }}
		{{ end }}
	{{ end }}
	{{/* nginx-proxy/nginx-proxy#1105 */}}
	{{ if (eq $server_found "false") }}
        # Fallback entry
        server 127.0.0.1 down;
	{{ end }}
	}
{{ end }}

# If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
# scheme used to connect to this server
map $http_x_forwarded_proto $proxy_x_forwarded_proto {
  default $http_x_forwarded_proto;
  ''      $scheme;
}

# If we receive X-Forwarded-Port, pass it through; otherwise, pass along the
# server port the client connected to
map $http_x_forwarded_port $proxy_x_forwarded_port {
  default $http_x_forwarded_port;
  ''      $server_port;
}

# If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
# Connection header that may have been passed to this server
map $http_upgrade $proxy_connection {
  default upgrade;
  '' close;
}

gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

log_format vhost '$host [$time_local] '
                 '"$request" $status $body_bytes_sent '
                 '"$http_referer" '
                 '"$upstream_addr"';

error_log /dev/stderr;

# HTTP 1.1 support
proxy_http_version 1.1;
proxy_buffering off;
proxy_set_header Host $http_host;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $proxy_connection;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;
# proxy_set_header X-Forwarded-Ssl $proxy_x_forwarded_ssl;
proxy_set_header X-Forwarded-Port $proxy_x_forwarded_port;
proxy_set_header X-Original-URI $request_uri;

# Mitigate httpoxy attack (see README for details)
proxy_set_header Proxy "";

server {
	server_name _; # This is just an invalid value which will never trigger on a real hostname.
	server_tokens off;
	listen 80;
	return 503;
}

{{ range $host, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}
{{ template "upstream" (dict "Upstream" $host "Containers" $containers "Networks" $CurrentContainer.Networks "Debug" $debug_all) }}
{{ end }}

server {
	server_name localhost;
	server_tokens off;
	listen 80 default_server;

    root /public;

    {{ range $host, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}
    {{ template "echo_subrequests" (dict "Endpoint" "/metrics" "Containers" $containers "Networks" $CurrentContainer.Networks) }}
    {{ end }}

    location / {
        client_max_body_size 4G;
        # try_files $uri $uri/ @rails;
        try_files $uri @rails;
    }

    location /__accel_redirect {
        internal;
        alias   /private/;
        add_header Content-Encoding $upstream_http_content_encoding;
        gzip off;
    }

    location @rails {
        proxy_pass http://workers;
        proxy_set_header  X-Accel-Mapping       /private=/__accel_redirect;
        proxy_read_timeout 240s;
        proxy_send_timeout 240s;
    }
}
